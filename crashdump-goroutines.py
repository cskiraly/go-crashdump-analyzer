# Copyright (c) 2025 Csaba Kiraly

# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:

# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.

# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

# This script parses a Go runtime crash dump and extracts goroutine information.
# It is intended to be used with the crash dump generated by the Go runtime
# when a panic occurs.
# The script reads the crash dump file, extracts goroutine information, and
# generates an interactive html graph of the goroutines and their relationships.
# It can also generate a static image (-s goroutines.svg) in svg, pdf or png
# format.

# Usage:
# python crashdump-goroutines.py <crash_dump_file> [-o <output_file>] [-v] [-s <extra_output_file>]

# The log file to be parsed is in the following format:
# goroutine 3441649 [select]:
# github.com/ethereum/go-ethereum/p2p.(*Peer).run(0xc023f6de30)
#         github.com/ethereum/go-ethereum/p2p/peer.go:291 +0x287
# github.com/ethereum/go-ethereum/p2p.(*Server).runPeer(0xc0001c8008, 0xc023f6de30)
#         github.com/ethereum/go-ethereum/p2p/server.go:974 +0x193
# created by github.com/ethereum/go-ethereum/p2p.(*Server).launchPeer in goroutine 4881
#         github.com/ethereum/go-ethereum/p2p/server.go:957 +0xd1
#
# goroutine 4881 [select, 1 minutes]:
# github.com/ethereum/go-ethereum/p2p.(*Server).run(0xc0001c8008)
# 	github.com/ethereum/go-ethereum/p2p/server.go:636 +0x491
# created by github.com/ethereum/go-ethereum/p2p.(*Server).Start in goroutine 1
# 	github.com/ethereum/go-ethereum/p2p/server.go:416 +0x4a8
#
# goroutine 4275 [chan receive, 85 minutes]:
# github.com/cockroachdb/pebble.(*tableCacheShard).releaseLoop.func1({0x20d1c88?, 0xc000e849f0?})
#         github.com/cockroachdb/pebble@v1.1.2/table_cache.go:385 +0x8e
# runtime/pprof.Do({0x20d1710?, 0x30bbde0?}, {{0xc000390fc0?, 0x5d4272168c9b4b5c?, 0x36f27e4a7ba271d5?}}, 0xc00069bfa8)
#         runtime/pprof/runtime.go:51 +0x8c
# github.com/cockroachdb/pebble.(*tableCacheShard).releaseLoop(0xb38?)
#         github.com/cockroachdb/pebble@v1.1.2/table_cache.go:383 +0x4c
# created by github.com/cockroachdb/pebble.(*tableCacheShard).init in goroutine 1
#         github.com/cockroachdb/pebble@v1.1.2/table_cache.go:375 +0xe5

import sys
import re
import argparse
from typing import List
import networkx as nx
from networkx.drawing.nx_agraph import graphviz_layout
import matplotlib.pyplot as plt
from pyvis.network import Network

# Define the structure of the goroutine information
class Goroutine:
    def __init__(self, id: int, waiting_for: str):
        self.id = id
        self.lines = []
        self.stack = []
        self.waiting_for = waiting_for
        self.created_by = None

    def __repr__(self):
        return f"Goroutine(id={self.id}, wait={self.waiting_for})"

# Function to parse the crash dump file and extract goroutine information
def parse_crash_dump(file_path: str) -> List[Goroutine]:
    goroutines = []
    with open(file_path, 'rb') as f:
        data = f.read()

    # Find the start of the goroutine information
    goroutine_start = data.find(b'goroutine ')
    if goroutine_start == -1:
        print("No goroutine information found in the crash dump.")
        return []

    # Extract the goroutine information
    goroutine_data = data[goroutine_start:]
    lines = goroutine_data.decode('utf-8').splitlines()
    current_goroutine = None

    for line in lines:
        if line.startswith("goroutine"):
            if current_goroutine:
                goroutines.append(current_goroutine)
            # Extract the goroutine ID
            match = re.search(r'goroutine (\d+) \[(.*)\]', line)
            if match:
                gid = int(match.group(1))
                waitingfor = match.group(2)
                current_goroutine = Goroutine(gid, waitingfor)
        elif line.startswith("created by"):
            match = re.search(r'created by (.*) in goroutine (\d+)', line)
            if match:
                created_by_id = int(match.group(2))
                current_goroutine.created_by = created_by_id
                current_goroutine.stack.append(match.group(1))
        elif line.startswith("\t"):
            # Extract the stack trace information
            current_goroutine.lines.append(line.strip())
        elif line == "":
            # Empty line indicates the end of a goroutine
            if current_goroutine:
                goroutines.append(current_goroutine)
                current_goroutine = None
        else:
            # Extract the stack trace information
            current_goroutine.stack.append(line.strip())

    if current_goroutine:
        goroutines.append(current_goroutine)

    return goroutines

# Function to print the goroutine information in a human-readable format
def print_goroutines(goroutines: List[Goroutine]):
    for g in goroutines:
        print(f"Goroutine ID: {g.id}")
        if g.waiting_for:
            print(f"Waiting for: {g.waiting_for}")
        if g.created_by:
            print(f"Created by: {g.created_by}")
        print("Lines:")
        for line in g.lines:
            print(f"  {line}")
        if g.stack:
            print("Stack Trace:")
            for line in g.stack:
                print(f"  {line}")
        print()

# Main function to run the script
def analyze(logfile: str, output: str, verbose: bool, savefile: str, linktarget: str):
    goroutines = parse_crash_dump(logfile)
    if verbose:
        print_goroutines(goroutines)

    # collect statistics about waiting_for reasons:
    waiting_for_count = {}
    for g in goroutines:
        if g.waiting_for:
            if g.waiting_for not in waiting_for_count:
                waiting_for_count[g.waiting_for] = 0
            waiting_for_count[g.waiting_for] += 1
    # sort according to the count
    waiting_for_count = dict(sorted(waiting_for_count.items(), key=lambda item: item[1], reverse=True))
    # print the waiting_for reasons
    print("Waiting for reasons:")
    for reason, count in waiting_for_count.items():
        print(f"  {reason}: {count}")

    # Create a directed graph
    graph = nx.DiGraph()
    # Add nodes for each goroutine
    for g in goroutines:
        graph.add_node(g.id)
    for g in goroutines:
        # Add edges for created_by relationships
        if g.created_by is not None:
            graph.add_edge(g.created_by, g.id)

    # Draw the graph automatically with a nice horizontal layout
    pos = graphviz_layout(graph, prog="dot", args="-Grankdir=LR -Gnodesep=0.5")
    # Set node labels
    labeldict = {}
    for g in goroutines:
        labeldict[g.id] = f"{g.id}: [{g.waiting_for}]\n{g.stack[-1]}\n{g.stack[0]}"

    # Optionally, you can visualize the goroutine relationships using NetworkX
    if savefile: 
        # Draw the graph to pdf
        plt.figure(figsize=(64, 128))
        nx.draw(graph, pos, labels=labeldict, with_labels=True, arrows=True, node_size=1000,
                node_color="lightblue", font_size=8, font_color="black", font_weight="bold")
        # nx.draw_networkx(graph, pos, arrows=True)
        plt.title("Goroutine Relationships")
        plt.savefig(savefile)


    # Plot with pyvis to html
    def line_to_link(line):
        # convert the line to a link, e.g.
        # line: "github.com/ethereum/go-ethereum/p2p/server.go:958 +0xd1"
        # link: "https://github.com/ethereum/go-ethereum/blob/master/p2p/server.go#L958"
        match = re.search(r'github.com/([^/]+)/([^/@]+)(@[^/]+)?/(.+):(\d+)', line)
        if match:
            org = match.group(1)
            repo = match.group(2)
            version = match.group(3)
            filepath = match.group(4)
            lineno = match.group(5)

            if version:
                branch = version[1:]
            else:
                branch = 'master'
            return f"https://github.com/{org}/{repo}/blob/{branch}/{filepath}#L{lineno}"

    def line_to_linkedline(stackline, codeline, linktarget):
        link = line_to_link(codeline)
        if link:
            return f'<a href="{link}" target="{linktarget}">{stackline}</a>'
        else:
            return stackline

    for g in goroutines:
        # print the stack trace to string, separated by newlines
        links = [line_to_linkedline(g.stack[i], line, linktarget) for i, line in enumerate(g.lines)]
        stack = "<br/>".join(links)

        # get the first and last element of stack, only the part after the last /
        shortname = g.stack[0].split("/")[-1]
        if len(g.stack) > 1:
            shortname += "\n"+g.stack[-1].split("/")[-1]

        # set the label to the last part of the stack trace
        graph.nodes[g.id]['label'] = f"{shortname}\n[{g.waiting_for}]"
        graph.nodes[g.id]['title'] = f"{g.id}: [{g.waiting_for}]<br/>{stack}"
        graph.nodes[g.id]['shape'] = 'box'

        # color the nodes according to the waiting_for reason
        if g.waiting_for:
            if g.waiting_for == "chan receive":
                graph.nodes[g.id]['color'] = 'lightblue'
            elif g.waiting_for.startswith("select"):
                graph.nodes[g.id]['color'] = 'lightgreen'
            elif g.waiting_for == "runnable":
                graph.nodes[g.id]['color'] = 'lightyellow'
            elif g.waiting_for == "IO wait":
                graph.nodes[g.id]['color'] = 'lightgray'
            elif g.waiting_for == "sleep":
                graph.nodes[g.id]['color'] = 'lightcoral'
            elif g.waiting_for == "sync.Cond.Wait":
                graph.nodes[g.id]['color'] = 'lightcyan'
            elif g.waiting_for == "sync.Mutex.Lock":
                graph.nodes[g.id]['color'] = 'blue'
            elif g.waiting_for.startswith("chan receive"):
                graph.nodes[g.id]['color'] = 'orange'
            elif g.waiting_for == "chan receive (nil chan)":
                graph.nodes[g.id]['color'] = 'darkorange'
            elif g.waiting_for.startswith("chan send"):
                graph.nodes[g.id]['color'] = 'red'

            else:
                graph.nodes[g.id]['color'] = 'lightpink'

    net = Network(
        directed = True,
        select_menu = True, # Show part 1 in the plot (optional)
        filter_menu = True, # Show part 2 in the plot (optional)
    )
    net.show_buttons() # Show part 3 in the plot (optional)
    net.from_nx(graph) # Create directly from nx graph
    net.show(output, notebook=False)

if __name__ == "__main__":

    # parse the command line arguments
    parser = argparse.ArgumentParser(
        description='Parse a Go runtime crash dump log and extract goroutine information.'
    )
    parser.add_argument('logfile', help='Path to the crash dump log file')
    parser.add_argument('-o', '--output', default='goroutine_graph.html', help='Output file for the graph (default: goroutine_graph.html)')
    parser.add_argument('-v', '--verbose', action='store_true', help='Print more goroutine info on stdout')
    parser.add_argument('-s', '--savefile', help='Generate a static graph of goroutines in a file (yourfile.(svg|pdf|png))')
    parser.add_argument('-l', '--linktarget', default='_blank', help='browser target for opening source links (default: _blank)')
    args = parser.parse_args()

    analyze(args.logfile, args.output, args.verbose, args.savefile, args.linktarget)
